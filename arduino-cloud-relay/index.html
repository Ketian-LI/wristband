<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>DragonLink · Live Party Chronicle</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    :root {
      --parchment-bg: #f5e7c6;
      --parchment-deep: #e2cf9c;
      --ink-main: #3b2b26;
      --ink-muted: #7a5c4b;
      --ink-strong: #5c3d2b;

      --block-party: #d79c5b;
      --block-dragon: #b5523b;
      --block-magic: #4f7c6b;
      --block-sky: #6f8fa7;

      --border-dark: #57402e;
      --border-light: #e0cba0;

      --shadow-soft: 0 16px 40px rgba(70, 40, 20, 0.45);
      --radius-card: 18px;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      min-height: 100vh;
      background:
        radial-gradient(circle at top, #f4e6c2 0, #e1cf9d 40%, #c7a774 80%),
        repeating-linear-gradient(135deg, rgba(0,0,0,0.03) 0, rgba(0,0,0,0.03) 1px, transparent 1px, transparent 4px);
      color: var(--ink-main);
      font-family: "Times New Roman", "Songti SC", "Noto Serif SC", serif;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
    }

    .scroll-shell {
      width: 100%;
      max-width: 1120px;
      background:
        linear-gradient(145deg, rgba(255,255,255,0.78), rgba(244,225,181,0.95)),
        repeating-linear-gradient(0deg, rgba(255,255,255,0.15) 0, rgba(255,255,255,0.15) 1px, transparent 1px, transparent 3px);
      border-radius: 22px;
      border: 2px solid var(--border-dark);
      box-shadow: var(--shadow-soft);
      position: relative;
      overflow: hidden;

      max-height: 90vh;
      overflow-y: auto;
    }

    .scroll-shell::before,
    .scroll-shell::after {
      content: "";
      position: absolute;
      top: -40px;
      bottom: -40px;
      width: 32px;
      background:
        radial-gradient(circle at center, #d9b177 0, #8d5b34 65%, #3d2316 100%);
      box-shadow: inset 0 0 0 3px rgba(237,213,168,0.9);
    }

    .scroll-shell::before {
      left: -18px;
      border-radius: 999px;
    }

    .scroll-shell::after {
      right: -18px;
      border-radius: 999px;
    }

    .scroll-inner {
      position: relative;
      padding: 20px 24px 18px;
      border-left: 1px dashed rgba(87, 64, 46, 0.4);
      border-right: 1px dashed rgba(87, 64, 46, 0.4);
    }

    .header-row {
      display: flex;
      justify-content: space-between;
      gap: 16px;
      align-items: flex-start;
      margin-bottom: 14px;
      flex-wrap: wrap;
    }

    .title-block h1 {
      font-size: 1.4rem;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      font-weight: 600;
      color: var(--ink-strong);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .title-emblem {
      font-size: 1.2rem;
      border-radius: 999px;
      padding: 6px 10px;
      background: var(--block-party);
      color: #24160e;
      border: 1px solid #6e4623;
      box-shadow: 0 3px 0 #6e4623;
    }

    .subtitle {
      margin-top: 4px;
      font-size: 0.88rem;
      color: var(--ink-muted);
      max-width: 480px;
      line-height: 1.4;
    }

    .status-panel {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 14px;
      border-radius: 999px;
      border: 2px solid var(--border-dark);
      background:
        linear-gradient(145deg, #f4e3bf, #e1c99a);
      box-shadow: 0 6px 0 rgba(87, 64, 46, 0.9);
      min-width: 230px;
    }

    .status-seal {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: 2px solid #3d2316;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.9rem;
      background: #b83f33;
      color: #fef3c7;
      box-shadow: inset 0 0 0 2px #fcd34d, 0 0 0 3px rgba(0,0,0,0.18);
      position: relative;
    }

    .status-seal::after {
      content: "";
      position: absolute;
      inset: 3px;
      border-radius: 50%;
      border: 1px solid rgba(0,0,0,0.25);
    }

    .status-texts {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .status-main {
      font-size: 0.8rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      color: var(--ink-strong);
    }

    .status-sub {
      font-size: 0.74rem;
      color: var(--ink-muted);
    }

    .status-seal.online {
      background: #3f7c45;
      box-shadow: inset 0 0 0 2px #bbf7d0, 0 0 0 3px rgba(0,0,0,0.18);
    }

    .status-seal.online span {
      transform: rotate(-10deg);
    }

    .map-grid {
      display: grid;
      grid-template-columns: minmax(0, 1.5fr) minmax(0, 1.05fr);
      gap: 18px;
      align-items: stretch;
      margin-top: 12px;
    }

    @media (max-width: 860px) {
      .map-grid {
        grid-template-columns: minmax(0, 1fr);
      }
      .scroll-inner {
        padding: 16px 12px;
      }
    }

    .panel {
      border-radius: var(--radius-card);
      border: 2px solid var(--border-dark);
      background:
        linear-gradient(145deg, var(--parchment-bg), #f2dfb2);
      box-shadow: 0 10px 0 rgba(87, 64, 46, 0.9);
      position: relative;
      overflow: hidden;
    }

    .panel::before {
      content: "";
      position: absolute;
      inset: 0;
      background-image:
        radial-gradient(circle at top left, rgba(180, 120, 70, 0.25), transparent 55%),
        url("data:image/svg+xml,%3Csvg width='160' height='160' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M5 80 Q80 10 155 80 T305 80' fill='none' stroke='%23d6b47c' stroke-width='1.4' stroke-dasharray='5 4'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-size: cover, 260px 120px;
      background-position: center, bottom right;
      opacity: 0.25;
      pointer-events: none;
    }

    .panel-inner {
      position: relative;
      z-index: 1;
      padding: 12px 14px 12px;
    }

    .panel-heading {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      margin-bottom: 8px;
      gap: 8px;
    }

    .panel-title {
      font-size: 0.9rem;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: var(--ink-strong);
    }

    .panel-tag {
      font-size: 0.72rem;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      padding: 2px 10px;
      border-radius: 999px;
      border: 1px solid var(--border-dark);
      background: #fef3c7;
      color: #b45309;
      box-shadow: 0 2px 0 #b45309;
      white-space: nowrap;
    }

    .block-row {
      display: grid;
      grid-template-columns: minmax(0, 1.4fr) minmax(0, 1fr);
      gap: 8px;
      margin-bottom: 10px;
      align-items: center;
    }

    .hero-metric {
      background: var(--block-party);
      border-radius: 14px;
      padding: 10px 12px;
      border: 2px solid #6b3b1d;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.3);
    }

    .hero-label {
      font-size: 0.74rem;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: #3b1f0f;
      margin-bottom: 4px;
    }

    .hero-main {
      font-size: 2.1rem;
      font-weight: 700;
      display: flex;
      align-items: flex-end;
      gap: 6px;
      color: #1b0f07;
    }

    .hero-main span.unit {
      font-size: 0.92rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      margin-bottom: 3px;
      color: #3b1f0f;
    }

    .hero-side {
      background: var(--block-magic);
      border-radius: 14px;
      padding: 8px 10px;
      border: 2px solid #23453b;
      color: #ecfdf5;
      font-size: 0.8rem;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .hero-side strong {
      font-size: 0.88rem;
    }

    .hero-side span {
      color: #bae6fd;
    }

    .trend-label {
      display: inline-block;
      margin-top: 4px;
      font-size: 0.74rem;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(0,0,0,0.2);
      background: rgba(255,255,255,0.58);
      color: #1b4332;
    }

    .map-frame {
      border-radius: 14px;
      border: 2px solid #324152;
      background: #f9f5e7;
      padding: 8px 8px 6px;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.1);
    }

    .chart-stack {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .chart-section {
      height: 130px;
      flex: 0 0 130px;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .chart-title {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      color: var(--ink-muted);
    }

    #chartA,
    #chartB {
      width: 100%;
      height: 100%;
    }

    .legend-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 4px;
      font-size: 0.74rem;
      color: var(--ink-muted);
    }

    .side-blocks {
      display: grid;
      grid-template-columns: minmax(0, 1fr);
      gap: 10px;
      margin-bottom: 10px;
    }

    .mini-block-row {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 8px;
    }

    .mini-block {
      border-radius: 12px;
      border: 2px solid var(--border-dark);
      padding: 6px 8px 7px;
      background: #f8ecd0;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.6);
      font-size: 0.78rem;
    }

    .mini-label {
      font-size: 0.7rem;
      color: var(--ink-muted);
      margin-bottom: 2px;
    }

    .mini-value {
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--ink-strong);
    }

    .mini-value.alt {
      color: var(--block-dragon);
    }

    .log-book {
      border-radius: 12px;
      border: 2px solid var(--border-dark);
      background:
        linear-gradient(160deg, #f6e5bf, #f1d8a2);
      padding: 6px 8px;
      font-family: "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Monaco,
        Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.74rem;
      height: 160px;
      overflow: auto;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.12);
    }

    .log-entry {
      margin-bottom: 2px;
      color: var(--ink-main);
    }

    .log-entry span.time {
      color: var(--ink-muted);
    }

    .log-entry span.source {
      color: var(--block-dragon);
      font-weight: 600;
    }

    .log-entry span.text {
      color: var(--ink-main);
    }

    .party-logs {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
    }

    .party-column {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .party-title {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--ink-muted);
    }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <div class="scroll-shell">
    <div class="scroll-inner">
      <div class="header-row">
        <div class="title-block">
          <h1>
            <span class="title-emblem">⚔️</span>
            DRAGONLINK SCROLL
          </h1>
          <p class="subtitle">
            Two distant adventuring parties share their status through a cloud-borne magic scroll.
            You are now watching their heartbeat, strength, and omens as they face the dragon.
          </p>
        </div>

        <div class="status-panel">
          <div id="status-seal" class="status-seal">
            <span>⏳</span>
          </div>
          <div class="status-texts">
            <div id="status-main" class="status-main">Linking Ritual</div>
            <div id="status-sub" class="status-sub">Summoning the cloud relay circle…</div>
          </div>
        </div>
      </div>

      <div class="map-grid">
        <!-- Left: two charts -->
        <div class="panel">
          <div class="panel-inner">
            <div class="panel-heading">
              <div class="panel-title">Dragon's Breath Gauge</div>
              <div class="panel-tag">Live · Enchanted</div>
            </div>

            <div class="block-row">
              <div class="hero-metric">
                <div class="hero-label">CURRENT MYSTIC VALUE (avg of 8 channels)</div>
                <div class="hero-main">
                  <span id="main-value">--</span>
                  <span class="unit">sigils</span>
                </div>
                <div id="trend-chip" class="trend-label" style="display:none;">
                  Δ +0
                </div>
              </div>

              <div class="hero-side">
                <div>
                  <strong>Latest change</strong>
                  <span id="metric-parsed">—</span>
                </div>
                <div>
                  Source party:
                  <span id="last-source">—</span>
                </div>
                <div>
                  Last update:
                  <span id="last-timestamp">—</span>
                </div>
              </div>
            </div>

            <div class="map-frame">
              <div class="chart-stack">
                <div class="chart-section">
                  <div class="chart-title">Party A channels</div>
                  <canvas id="chartA"></canvas>
                </div>
                <div class="chart-section">
                  <div class="chart-title">Party B channels</div>
                  <canvas id="chartB"></canvas>
                </div>
              </div>

              <div class="legend-row">
                <div>Y-range fixed: -50 ~ 50</div>
                <div>Approx. last 2 minutes</div>
              </div>
            </div>
          </div>
        </div>

        <!-- Right: metrics + A/B logs -->
        <div class="panel">
          <div class="panel-inner">
            <div class="panel-heading">
              <div class="panel-title">Party Ledger</div>
              <div class="panel-tag">A ↔ B two-way link</div>
            </div>

            <div class="side-blocks">
              <div class="mini-block-row">
                <div class="mini-block">
                  <div class="mini-label">Total messages recorded</div>
                  <div class="mini-value alt" id="metric-count">0</div>
                </div>
                <div class="mini-block">
                  <div class="mini-label">Last avg value</div>
                  <div class="mini-value" id="metric-parsed-mini">—</div>
                </div>
              </div>

              <div class="mini-block-row">
                <div class="mini-block">
                  <div class="mini-label">Messages from A</div>
                  <div class="mini-value" id="metric-count-A">0</div>
                </div>
                <div class="mini-block">
                  <div class="mini-label">Messages from B</div>
                  <div class="mini-value" id="metric-count-B">0</div>
                </div>
              </div>

              <div class="mini-block-row">
                <div class="mini-block">
                  <div class="mini-label">Last keyword</div>
                  <div class="mini-value" id="metric-last-key">—</div>
                </div>
                <div class="mini-block">
                  <div class="mini-label">Last party heard from</div>
                  <div class="mini-value" id="metric-last-team">—</div>
                </div>
              </div>

              <div class="party-logs">
                <div class="party-column">
                  <div class="party-title">Party A log</div>
                  <div class="log-book" id="log-A"></div>
                </div>
                <div class="party-column">
                  <div class="party-title">Party B log</div>
                  <div class="log-book" id="log-B"></div>
                </div>
              </div>

            </div>
          </div>
        </div>

      </div>

    </div>
  </div>

  <script>
    const protocol = location.protocol === "https:" ? "wss" : "ws";
    const WS_URL = `${protocol}://${location.host}/ws`;

    const statusSeal = document.getElementById("status-seal");
    const statusMain = document.getElementById("status-main");
    const statusSub = document.getElementById("status-sub");

    const mainValueEl = document.getElementById("main-value");
    const trendChipEl = document.getElementById("trend-chip");
    const metricParsedEl = document.getElementById("metric-parsed");
    const metricParsedMiniEl = document.getElementById("metric-parsed-mini");

    const metricCountTotalEl = document.getElementById("metric-count");
    const metricCountAEl = document.getElementById("metric-count-A");
    const metricCountBEl = document.getElementById("metric-count-B");

    const lastSourceEl = document.getElementById("last-source");
    const lastTimestampEl = document.getElementById("last-timestamp");
    const metricLastKeyEl = document.getElementById("metric-last-key");
    const metricLastTeamEl = document.getElementById("metric-last-team");

    const logAEl = document.getElementById("log-A");
    const logBEl = document.getElementById("log-B");

    let msgCountTotal = 0;
    const msgCountByRole = { A: 0, B: 0 };
    const lastAvgByRole = { A: null, B: null };

    // 8 fixed colors for 8 channels
    const CHANNEL_COLORS = [
      "#e63946", // ch1
      "#457b9d", // ch2
      "#2a9d8f", // ch3
      "#f4a261", // ch4
      "#1d3557", // ch5
      "#a8dadc", // ch6
      "#ffbe0b", // ch7
      "#8338ec"  // ch8
    ];

    const MAX_POINTS = 120;   // chart history per channel
    const MAX_LOG_LINES = 15; // per-party log max lines

    function setStatus(online, mainText, subText) {
      if (online) {
        statusSeal.classList.add("online");
        statusSeal.querySelector("span").textContent = "✨";
      } else {
        statusSeal.classList.remove("online");
        statusSeal.querySelector("span").textContent = "⏳";
      }
      statusMain.textContent = mainText;
      statusSub.textContent = subText || "";
    }

    function appendLog(roleKey, time, text) {
      const target = roleKey === "B" ? logBEl : logAEl;
      const div = document.createElement("div");
      div.className = "log-entry";
      const label = roleKey === "A" ? "A" : (roleKey === "B" ? "B" : "?");
      div.innerHTML =
        `<span class="time">[${time}]</span> ` +
        `<span class="source">${label}</span> ` +
        `<span class="text">→ ${text}</span>`;
      target.appendChild(div);

      // keep only last MAX_LOG_LINES per party
      while (target.children.length > MAX_LOG_LINES) {
        target.removeChild(target.firstChild);
      }
      target.scrollTop = target.scrollHeight;
    }

    // ----- Chart.js: two charts (A / B), 8 lines each -----
    const ctxA = document.getElementById("chartA").getContext("2d");
    const ctxB = document.getElementById("chartB").getContext("2d");

    const chartDataA = {
      labels: [],
      datasets: CHANNEL_COLORS.map((c, i) => ({
        label: `A ch${i + 1}`,
        data: [],
        tension: 0.25,
        borderWidth: 2,
        pointRadius: 0,
        fill: false,
        borderColor: c
      }))
    };

    const chartDataB = {
      labels: [],
      datasets: CHANNEL_COLORS.map((c, i) => ({
        label: `B ch${i + 1}`,
        data: [],
        tension: 0.25,
        borderWidth: 2,
        pointRadius: 0,
        fill: false,
        borderColor: c
      }))
    };

    const baseChartOptions = {
      responsive: true,
      maintainAspectRatio: false,
      animation: { duration: 0 },
      scales: {
        x: { display: false },
        y: {
          min: -50,
          max: 50,
          grid: { color: "rgba(87,64,46,0.25)" },
          ticks: {
            color: "#5c3d2b",
            font: { size: 10 }
          }
        }
      },
      plugins: { legend: { display: false } }
    };

    const chartA = new Chart(ctxA, {
      type: "line",
      data: chartDataA,
      options: baseChartOptions
    });

    const chartB = new Chart(ctxB, {
      type: "line",
      data: chartDataB,
      options: baseChartOptions
    });

    function clampValue(v) {
      if (v > 50) return 50;
      if (v < -50) return -50;
      return v;
    }

    function pushPartySeries(roleKey, valuesArray) {
      // 只用前 8 个通道
      const numeric = valuesArray
        .slice(0, 8)
        .map((v) => Number(v))
        .map((v) => (isNaN(v) ? null : clampValue(v)));

      const nowLabel = new Date().toLocaleTimeString("en-GB", {
        hour12: false,
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit"
      });

      let chartData = null;
      let chart = null;
      if (roleKey === "A") {
        chartData = chartDataA;
        chart = chartA;
      } else if (roleKey === "B") {
        chartData = chartDataB;
        chart = chartB;
      } else {
        return;
      }

      chartData.labels.push(nowLabel);
      if (chartData.labels.length > MAX_POINTS) {
        chartData.labels.shift();
      }

      chartData.datasets.forEach((ds, idx) => {
        const v = numeric[idx] ?? null;
        ds.data.push(v);
        if (ds.data.length > MAX_POINTS) {
          ds.data.shift();
        }
      });

      chart.update("none");
    }

    // fallback: parse last numeric from a string
    function parseNumeric(text) {
      const match = text.match(/(-?\d+(\.\d+)?)(?!.*\d)/);
      if (!match) return null;
      return parseFloat(match[1]);
    }

    function mapRoleToTeamLabel(role) {
      if (role === "A") return "Party A";
      if (role === "B") return "Party B";
      return role || "Unknown party";
    }

    function guessKeyWord(text) {
      const parts = text.split(":");
      if (parts.length <= 1) return text.slice(0, 12) || "—";
      return parts.slice(1).join(":").trim().slice(0, 12) || "—";
    }

    function parseMessage(raw) {
      let roleKey = "Unknown";
      let values = null;
      let textForLog = raw;

      if (!raw || typeof raw !== "string") {
        return { roleKey, values, textForLog };
      }

      raw = raw.trim();
      if (!raw) {
        return { roleKey, values, textForLog };
      }

      // 1) try JSON: {"board":"A","values":[...]} or {"role":"A", ...}
      if (raw.startsWith("{") && raw.endsWith("}")) {
        try {
          const obj = JSON.parse(raw);
          if (obj && typeof obj === "object") {
            if (Array.isArray(obj.values)) {
              values = obj.values;
              textForLog = obj.values.join(", ");
            } else if (typeof obj.data === "string") {
              textForLog = obj.data;
            }
            if (obj.role) roleKey = String(obj.role);
            else if (obj.board) roleKey = String(obj.board);
            else if (obj.id) roleKey = String(obj.id);
          }
        } catch (e) {
          // ignore
        }
      }

      // 2) if still no values, try "A:24,24,24..." text format
      if (!values) {
        const idx = raw.indexOf(":");
        if (idx > 0) {
          const tag = raw.slice(0, idx).trim();
          const payload = raw.slice(idx + 1).trim();
          const arr = payload.split(/[,\s]+/).map((v) => Number(v));
          if (arr.length >= 1 && !arr.every((v) => isNaN(v))) {
            values = arr;
            textForLog = payload;
            roleKey = tag;
          }
        }
      }

      // normalize role
      if (roleKey === "UNO_R4_A" || roleKey === "a" || roleKey === "A") {
        roleKey = "A";
      } else if (roleKey === "UNO_R4_B" || roleKey === "b" || roleKey === "B") {
        roleKey = "B";
      } else if (roleKey !== "A" && roleKey !== "B") {
        roleKey = "Unknown";
      }

      return { roleKey, values, textForLog };
    }

    // ----- WebSocket -----
    function connectWS() {
      setStatus(false, "Linking Ritual", "Summoning the cloud relay circle…");

      const ws = new WebSocket(WS_URL);

      ws.addEventListener("open", () => {
        setStatus(true, "Link Established", "The relay circle is stable. Listening to dragon and party pulses.");
      });

      ws.addEventListener("message", (event) => {
        const raw = String(event.data);
        const { roleKey, values, textForLog } = parseMessage(raw);

        const now = new Date();
        const timeStr = now.toLocaleTimeString("en-GB", { hour12: false });

        // counters
        msgCountTotal += 1;
        metricCountTotalEl.textContent = msgCountTotal.toString();

        if (roleKey === "A" || roleKey === "B") {
          msgCountByRole[roleKey] += 1;
          if (roleKey === "A") {
            metricCountAEl.textContent = msgCountByRole.A.toString();
          } else {
            metricCountBEl.textContent = msgCountByRole.B.toString();
          }
        }

        // compute average of 8 channels for the big value
        let avgVal = null;
        if (values && Array.isArray(values)) {
          const nums = values
            .slice(0, 8)
            .map((v) => Number(v))
            .filter((v) => !isNaN(v));
          if (nums.length > 0) {
            const sum = nums.reduce((a, b) => a + b, 0);
            avgVal = sum / nums.length;
          }
        } else {
          const single = parseNumeric(String(raw));
          if (single !== null) {
            avgVal = single;
          }
        }

        const teamLabel = mapRoleToTeamLabel(roleKey);
        const key = guessKeyWord(String(raw));

        metricLastKeyEl.textContent = key;
        metricLastTeamEl.textContent = teamLabel;
        lastSourceEl.textContent = teamLabel;
        lastTimestampEl.textContent = timeStr;

        if (avgVal !== null) {
          const vClamped = clampValue(avgVal);
          mainValueEl.textContent = vClamped.toFixed(0);
          metricParsedEl.textContent = `${vClamped.toFixed(2)} sigils`;
          metricParsedMiniEl.textContent = vClamped.toFixed(2);

          const prevAvg = lastAvgByRole[roleKey] ?? null;
          if (prevAvg !== null) {
            const diff = vClamped - prevAvg;
            const sign = diff >= 0 ? "+" : "";
            trendChipEl.style.display = "inline-block";
            trendChipEl.textContent = `Δ ${sign}${diff.toFixed(2)} (${roleKey || "?"})`;
          }
          if (roleKey === "A" || roleKey === "B") {
            lastAvgByRole[roleKey] = vClamped;
          }

          if (roleKey === "A" || roleKey === "B") {
            pushPartySeries(roleKey, values || [vClamped]);
          }
        } else {
          metricParsedEl.textContent = "—";
          metricParsedMiniEl.textContent = "—";
        }

        const logText = values && Array.isArray(values)
          ? values.slice(0, 8).map((v) => Number(v).toFixed(1)).join(", ")
          : String(textForLog);
        appendLog(roleKey, timeStr, logText);
      });

      ws.addEventListener("close", () => {
        setStatus(false, "Link Lost", "The circle has broken. Re-drawing runes in a few seconds…");
        setTimeout(connectWS, 3000);
      });

      ws.addEventListener("error", () => {
        setStatus(false, "Ritual Error", "Arcane disturbance detected. Please try again later.");
      });
    }

    connectWS();
  </script>
</body>
</html>
